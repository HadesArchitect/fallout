Contributing to Fallout
=======

Not familiar with Fallout? Check out the [README](README.md) first.

You can learn more about Fallout's architecture by reading the [docs](docs). Most of what you need to reference when contributing, can be found in the [extending Fallout section](docs/extending.md).

If you want to understand the internals of the queueing and running mechanism, there's a [class collaboration sketch here](docs/assets/TestRunner-collaborators.png); there's also a [collaboration sketch for the LiveLog here](docs/assets/LiveLog-collaborators.png).

There is also a [sequence diagram to show how the separate QUEUE and RUNNER processes interact here](docs/assets/queue-server-lifetime.png).

All of the above diagrams are generated from `.dot`/`.plantuml` files in [docs/assets](docs/assets) by the gradle `docs` task.

## Submitting Code

- Submit change requests via the Github Pull Request workflow.
- Make sure you run `./gradlew spotlessCheck compile` to make sure your code at least compiles and lints before pushing (the git hooks described below will do this for you).
  - If `spotlessCheck` fails, running `./gradlew spotlessApply` will fix the problems.

Some useful git hooks will be installed by running `./gradlew setupGit`; to get the full advantage of these, you should install `shellcheck`, and make sure your fallout-cli venv is active and has had `pip install -r requirements.txt` run in it.  The `shellcheck` is not currently enforced by CI, but everything else is; if you have modified something that wasn't shellcheck-clean, and you just want to check it in, use the `--no-verify` flag with `git commit`.

## FAQ
- I want to add some new functionality, e.g. support for running a testing tool, but I'm not sure where it goes?
    * Check out how [NosqlBench](src/main/java/com/datastax/fallout/harness/modules/nosqlbench) is structured.
    Make sure to keep configuration/installation logic in the ConfigurationManager, direct interaction in the Provider, and the actual testing in a Module(s).
- I want to add new validation. What's the difference between a checker, and an artifact checker?
    * Checkers operate over the jepsen history, and artifact checkers operate over the files (artifacts) generated by the test, such as stress logs, or system.log files.
- When should I emit the different [types](src/main/java/com/datastax/fallout/harness/Operation.java#L60) of [Operations](src/main/java/com/datastax/fallout/harness/Operation.java)?
    * Every module should emit an Operation of Type.invoke when it begins. Typically, most emitted Operations should be of type.info. Type.fail should be used for "probably bad" scenarios, such as dropped writes. Reserve type.error for "certainly bad" events, such as missing dependencies, or for errors in the Module code or Fallout framework. This lets us incorporate sophisticated checkers that understand when fail Operations are acceptable, such as lost writes when nodes are down.

## Common Gotchas

- When adding `PropertySpec`s to a component, make sure they're returned in `getPropertySpecs()`.

- When writing a `Module.run` method that doesn't just run something via `Node.execute()` (the abort mechanism will handle this for you), consider making it periodically check `Module.isTestRunAborted` so that it can be aborted.

- When calling `Node.execute()` on several nodes, be async-aware when dealing
  with the results:

  * If you need to wait on the results of several `Node.execute()` commands on multiple nodes, use the `Utils.waitFor*` methods;

  * Avoid nesting `CompletableFuture`s: for example, don't create a bunch of `CompletableFuture`s containing `NodeResponse.awaitAsync()`: use the `CompletableFuture` returned by `awaitAsync` (or even better, use `NodeResponse.waitFor*` or `NodeResponse.doWait().for*`).

- The following `NodeResponse` methods can block until a process has started (depending on the Provisioner in use, this may be a non-trivial amount of time): `getOutputStream`, `getErrorStream`, `getExitCode`.  You shouldn't need to call the first two, and you should only call `getExitCode` after a NodeResponse `isCompleted` (calling it before can raise an exception, depending on the Provisioner in use).  Rather than calling these methods directly, use the `NodeResponse` and `Utils` `waitFor*` methods to log output and check for completion.

## Code Style
We use a variant of the Apache code style. The main difference is in how we handle imports. You can see the instructions for importing the Fallout code style below, under [Using IntelliJ IDEA](CONTRIBUTING.md#Using-IntelliJ-IDEA).

### Assertions

Please do not use raw Java `assert`; use the methods provided by Guava's `Verify` and `Preconditions` in production code, and use AssertJ's `assertThat` in test code:

* In production code:
  * Use `Verify.verify` and `verifyNotNull`.
  * Bonus points: if you have something that is unambiguously a precondition, then feel free to use `Preconditions.checkArgument/checkState/checkNotNull`.  Hint: it's not a precondition if it's not at the beginning of a method.  But really, `Verify` is fine.
* If you're writing a test:
  * Use `AssertJ`'s `assertThat` (note this is _not_ the `assertThat` from junit).

## Using IntelliJ IDEA

This is based on IDEA version 2019.3.

### Code Style

The `./gradlew spotlessCheck` task uses the eclipse formatting settings in `eclipse-format.prefs` to enforce a consistent format (we use the eclipse formatter because there's no support for running the IDEA formatter in CI).

Settings for IntelliJ that closely match this are in `.editorconfig`, to provider formatting while-you-type.  In `Settings >  Editor > Code Style` make sure `Enable EditorConfig support` is checked.  These settings only closely match, though: continuation indentation behaviour differs.

To ensure `./gradlew spotlessCheck` passes without having to run `./gradlew spotlessApply`, you can use the following plugins and settings to make IntelliJ correctly format your code when you save a file:

* Install the [Eclipse Code Formatter](https://plugins.jetbrains.com/plugin/6546-eclipse-code-formatter) plugin
* Install the [Save Actions](https://plugins.jetbrains.com/plugin/7642-save-actions) plugin
* Restart the IDE

* Open `Settings`, navigate to `Other Settings > Eclipse Code Formatter`, and apply the following settings:

   ![idea eclipse code formatter settings](docs/assets/CONTRIBUTING/idea-eclipse-code-formatter-settings.png)

   ...i.e.:

   * `Use the Eclipse Code Formatter` is on;
   * `Enable Java` is on
   * The `eclipse-format.prefs` in your checked-out fallout repo is selected as the `Eclipse Java Formatter config file`.

* Navigate to `Other Settings > Save Actions`, and apply the following settings:

   ![idea save actions settings](docs/assets/CONTRIBUTING/idea-save-actions-settings.png)

   ...i.e.:

   * `Activate save actions on save` is on;
   * `Reformat only changed code` is on.

### Importing as a project or module

* Import `build.gradle` as a gradle project or module.  You can safely ignore any messages about `Duplicate content roots detected`.

* Open `Project Structure...`, and make sure a Java 11 Project JDK is set.

* Open `Settings`, navigate to `Build, Execution, Deployment > Compiler > Annotation Processors`, and make sure the `Enable annotation processing` checkbox is checked:

    ![idea annotation processing settings](docs/assets/CONTRIBUTING/idea-annotation-processing.png)

* Then. navigate to `Build, Execution, Deployment > Build Tools > Gradle` and make sure that the settings are as follows:

    ![gradle settings](docs/assets/CONTRIBUTING/idea-gradle-settings.png)

    ...i.e.:

    * `Generate *.iml files for modules imported from Gradle` is off;
    * `Build and run using` and `Run tests using` are both set to `Gradle`;
    * `Use Gradle from` is set to `'gradle-wrapper.properties' file`;
    * and `Gradle JVM` is `Use Project JDK`.

* In the toolbar drop-down at the top of the main window, select `Edit Configurations...`, go to `Templates > Gradle`, and set the `Environment Variables` as follows (click `[=]` button):

    * `ANT_HOME`: (path to your Ant installation)
    * `M2_HOME`: (path to your Maven installation)
    * `PYENV_VERSION`: (the name of your pyenv virtualenv you've setup for fallout. If you're not using pyenv, see below for controlling the env.)
    * `JAVA_HOME`, `JAVA11_HOME`: the installation of the Java 11 JDK
    * `JAVA8_HOME`: the installation of the Java 8 JDK

  (An older version of this document advised setting `-PtestForkEvery=0` in the `Templates > Gradle` dialog; if you've done this, please remove the setting).

* To run the fallout server, open the Gradle panel, navigate to `fallout > Tasks > application` and double-click `runServer`.

* You may need to control the environment used by IDEA by launching from the command  line in a terminal that has the desired environment (e.g. activated python virtual environment). E.g. on OSX: `open -a "IntelliJ IDEA Community"`.
